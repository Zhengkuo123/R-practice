# 正则表达式的功能
![stringr](https://user-images.githubusercontent.com/95266042/158171317-4a7785ba-529a-48cf-ae8f-6d608f18316b.png)
### 查找Detect pattern
### 定位Locate pattern
### 取回Extract pattern
### 替换Replace pattern

```R
ATG([ATCG]{3})+(TGA|TAG|TAA)
```

## 字符串处理的R包stringr
首先创建一个需要练习的字符串
```R
strings <- c(
  "apple", 
  "219 733 8965", 
  "329-293-8753", 
  "Work: 579-499-7527; Home: 543.355.3679"
)
```
创建一个可以匹配电话号码的模式

### 正则表达式中的三个括号
```R
()## 大内容的分隔
[]## 选项
{}## 次数
```
中括号`[]`表示选项，代表内部数据任意选择，比如[ATCG],表示A，T，C，G四个字符随意选择；
如果是数字也是同样的规则[1356],表示1，3，5，6这4个选项；
如果嫌麻烦，可用`-`连接起始代表范围，
比如[A-Z],代表大写的26个字母；

比如[a-z]，代表小写的26个字母；

比如[0-9]，表示0到9的10个数字；

还可以混写，
比如[0-9a-zA-Z]，代表数字和字母

### 编写第一个正则表达式
构建一个识别电话电话的模式
```R
pattern <- "([1-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})"
```
首先有三个括号`()`，里边的内容分别是
```R
[1-9][0-9]{2} ##第1个数字不为0，第2个数字是0-9，第3个数字是重复第2个数字
[0-9]{3} ##3个数字，取值0-9，重复3次
[0-9]{4} ##4个数字，取值0-9，重复4次
```
这3个大内容用`[- .]`来间隔，分别`-`和` `和`.`号。
再次理解该模式
```R
pattern <- "([1-9][0-9]{2})[- .]([0-9]{3})[- .]([0-9]{4})"
```
### 用str_view函数学习正则表达式
```R
str_view(strings,pattern)
```
返回结果
<img width="306" alt="image" src="https://user-images.githubusercontent.com/95266042/158176174-65610f18-8ca7-4363-9a03-e6e10503109a.png">

注意看第4行，只识别了第一个符合pattern的元素
```R
str_view_all(strings, pattern)
```
<img width="296" alt="image" src="https://user-images.githubusercontent.com/95266042/158176895-3543292f-7517-4f00-92d9-38b06cf68aa3.png">

这里展示的是所有符合pattern的元素

#### 1.查找
`str_detect`，从strings中检测能否和pattern匹配，返回的是逻辑值，有点像`grepl`
```R
str_detect(strings, pattern)
```
<img width="310" alt="image" src="https://user-images.githubusercontent.com/95266042/158176977-2985266d-ef7c-4773-9205-3baa5b605464.png">


